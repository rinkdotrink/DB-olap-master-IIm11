\section{Testvorbereitung}
Wir wählen die InnoDB als Speichermaschine aus, da sie die Transaktionssicherheit gewährleistet und sich dadurch für das Betreiben eines Webshops am besten eignet. 
Jede Versuchsreihe entspricht einer bestimmten Konfiguration und besteht aus vier Testläufen zu je einem Use Case. Am Anfang  werden Testdaten mit einer  bestimmten Anzahl von Kunden, einer konstanten Anzahl von Produkten (1000), einer konstanten Anzahl von Warenkörben pro Kunde(5) und genauso einer konstanten Anzahl von Produkten pro Warenkorb(5) generiert. Die Anzahl der Kunden erhöht sich mit jedem Testlauf. In jeder Versuchsreihe werden die vier verschiedenen Use Cases betrachtet, die durch eine unterschiedliche SELECT-Anweisung an die MySQL-Datenbank realisiert werden:
\subsection{SELECT-Anweisungen}
\begin{enumerate}
\item \textbf{Use Case 1: Welches Produkt wurde wie oft gekauft?}
\lstset{language=Java,caption={UseCase1},label=Use Case 1}
\lstinputlisting[language=Java]{Christof/Listings/UseCase1.java}
\item \textbf{Wieviel Umsatz wurde von wem in bestimmtem Zeitraum generiert?}
\lstset{language=Java,caption={UseCase2},label=Use Case 2}
\lstinputlisting[language=Java]{Christof/Listings/UseCase2.java}
\item \textbf{Wie viele Kunden haben in bestimmten Zeitraum bestellt?}
\lstset{language=Java,caption={UseCase3},label=Use Case 3}
\lstinputlisting[language=Java]{Christof/Listings/UseCase3.java}
\item \textbf{Wie viel Umsatz wurde an den ersten drei Tagen der ersten drei Monate generiert?}
\lstset{language=Java,caption={UseCase4},label=Use Case 4}
\lstinputlisting[language=Java]{Christof/Listings/UseCase4.java}
\end{enumerate}

\subsection{Konfigurationen der MySQL-Datenbank und der Tabellen}
Jede Versuchsreihe testet die SELECT-Anweisungen mit einer bestimmten Konfiguration der MySQL-Datenbank und der Tabellen. Vor jedem Testlauf werden die entsprechenden Konfigurationseintellungen mit SQL-Anweisungen durchgeführt.
\begin{enumerate}
\item \textbf{K1} : Kaltstart ohne Index
\item \textbf{K2} : Warmstart ohne Index
\item \textbf{K3} : Hash-Indizes auf Primary Keys und Foreign Keys / ohne Partitioning
\item \textbf{K4} : B-Tree-Indizes auf Primary Keys und Foreign Keys / ohne Partitioning
\item \textbf{K5} : Hash-Indizes auf Primary Keys und Foreign Keys sowie B-Tree-Index auf Datum / ohne Partitioning
\item \textbf{K6} : Hash-Indizes auf Primary Keys und Foreign Keys sowie B-Tree-Index auf Datum / mit List-Partitioning auf MONTH(Datum) für jedes Quartal
\item \textbf{K7} : Hash-Indizes auf Primary Keys und Foreign Keys sowie B-Tree-Index auf Datum / mit Hash-Partitioning auf MONTH(Datum) für jeden Monat
\item \textbf{K8} : Hash-Indizes auf Primary Keys und Foreign Keys sowie B-Tree Index auf Datum / mit Range-Partitioning auf COLUMNS(Datum) für jedes Quartal
\item \textbf{K9} : Hash Indizes auf Primary Keys und Foreign Keys sowie B-Tree-Index auf Datum / mit Sub-Partitioning (Range-Partitioning quartalsweise auf Datum und für jedes Quartal jeweils vier Hash-Partitions auf TO\_DAYS(Datum))
\item \textbf{K10}: Hash-Indizes auf Primary Keys und Foreign Keys / mit Sub-Partitioning (Range-Partitioning quartalsweise auf Datum und für jedes Quartal jeweils vier Hash-Partitions auf TO\_DAYS(Datum)
\end{enumerate}

\subsection{EXPLAIN-Anweisung}
Bei den SQL-Abfragen stellten wir bei jeder SELECT-Anweisung ein EXPLAIN davor, um nützliche Informationen zum Ausführungsplan des Optimierers zu erhalten. Die EXPLAIN-Anweisung liefert u.a. Daten darüber, ob die Indizes auch wirklich benutzt wurden, in welcher Reihenfolge die Tabellen verknüpft werden sowie weitere Informationen, die helfen sollen die SELECT-Anweisungen zu beschleunigen.  
\subsection{EXPLAIN PARTITIONS-Anweisung}
Diese Anweisung liefert zusätzlich Informationen über die verwendeten Partitionen. Man kann sie jedoch nur auf RANGE- oder LIST-partitionierte Tabellen verwenden. Bei KEY- oder HASH-Partitionen ist sie unbrauchbar, da automatisch alle Partitionen ausgegeben werden. 

\section{Testdurchführung}

\subsection{Annahmen und Vorüberlegungen}
\begin{enumerate}
\item \textbf{K1 und K2} \\ 
Der Warmstart ohne Index(\textbf{K2}) sollte gegenüber einem Kaltstart ohne Index(\textbf{K1}) eine Geschwindigkeitssteigerung bewirken, da die Queries und deren Ergebnismenge durch die vorherige Abfrage in Query-Cache gespeichert sein sollten.
\item \textbf{K3 und K4} \\
Das Hinzufügen von Indizes ist der erste wichtige Schritt bei der Optimierung von SELECT-Anweisungen und sollte bei der richtigen Formulierung der SELECT-Anweisung einen enormen Geschwindigkeitsvorteil gegenüber Abfragen auf Tabellen ohne Indizes bieten. Es ist die Frage zu beantworten, ob es bei den vier Use Cases einen großen Geschwindigkeitsunterschied zwischen der Hash-Indizierung(\textbf{K3}) und der B-Tree-Indizierung(\textbf{K4}) gibt und wodurch sich eventuelle Unterschiede ergeben.  
\item \textbf{K5} \\ 
Wenn man die Konfiguration K3 nehmen und diese um ein B-Tree-Index auf das Datum(\textbf{K5}) ergänzen, sollten bei dem UseCase3 die Zeilen mit dem gesuchten Datum schneller gefunden werden als ohne den B-Tree-Index.
\item \textbf{K6} \\ 
Mit einer zusätzlichen List-Partitionierung auf die drei Monate in jedem Quartal (\textbf{K6}) müsste die Suche nach einem konstanten Datumswert, wie es im UseCase3 der Fall ist, beschleunigt werden, denn er müsste nur in der einen Partition suchen. Interessant ist hierbei auch, wie die List-Partitionierung mit BETWEEN beim UseCase2 umgeht.    
\item \textbf{K7} \\ 
Mit einer Hash-Partitionierung auf die 12 Monate (\textbf{K7}) würde es einen Vorteil bringen, wenn nur auf eine bzw. im UseCase4 auf drei Partitionen zugegriffen wird. Wenn jedoch alle Partitionen durchsucht werden, dann bringt es Nachteile. Es stellt sich wieder die Frage, wie reagiert die Hash-Partitionierung auf eine BETWEEN-Anweisung.  
\item \textbf{K8} \\
Die Range-Partitionierung auf die Quartale(\textbf{K8}) sollte eigentlich die Geschwindigkeit für den UseCase2 mit der BETWEEN-Anweisung verkürzen. Denn bei dem verwendeten Range entspricht eine Partition jeweils einem Quartal und im UseCase2 wird die Datum-Spalte nach Werten in einem Quartal durchsucht.
\item \textbf{K9 und K10} \\
Die Konfiguration \textbf{9} unterscheidet sich von der Konfiguration \textbf{10} dadurch, dass sie ein B-Tree-Index auf das Datum enthält. Bei beiden Konfigurationen werden insgesamt 16 Teilpartitionen auf das Datum erstellt. Es soll dadurch herausgefunden werden, ob die Teilpartitionierung bei diesen SELECT-Anweisungen die Ausführung beschleunigt. 
\end{enumerate}
\subsection{Testergebnisse bei einer Million Kunden}
In der darunterliegenden Tabelle werden die Messergebnisse für \textbf{K3} bis \textbf{K10}  bei einer Anzahl von einer Million Kunden dargestellt. Diese Messwerte sind am aussagekräftigsten und wurden deshalb für die Analyse von den anderen Messwerten hervorgehoben. Alle anderen Messwerte dienten bei der Analyse dazu, um Vergleichswerte zu haben und um eventuelle Messfehler aufzudecken. Alle Messwerte sind Angaben in Sekunden. 
\begin{figure}[htp]
\centering
\includegraphics[width=0.75\textwidth]{Christof/Bilder/auswert1.jpg}
\caption{Testergebnisse}
\label{fig:auswert1}
\end{figure}

\subsection{Testauswertung}
\begin{enumerate}
\item Der Kaltstart ohne Index(K1) gegenüber dem Warmstart ohne Index(K2) hat keinen Geschwindigkeitsvorteil gebracht. Die Werte unterscheiden sich nur sehr gering voneinander. Wahrscheinlich liegt es an der geringen Komplexität der Statements und der kleinen Anzahl von Tabellen, da das Parsen dadurch nicht viel zeitaufwändiger ist.
\item Die Indizes brachten wie erwartet einen enormen Geschwindigkeisunterschied, bei 100 Tausend Kunden hat die Abfrage für den Use Case 1 um den Faktor 29 kürzer gedauert. Im direkten Vergleich zwischen K3 und K4 gab es so gut wie keine Unterschiede bei allen Use Cases. Auch der Ausführungsplan mit Hilfe der EXPLAIN-Anweisung zeigte keine Unterschiede bei den Zugriffstypen. Bei allen Use Cases wurde auf die selbe Art auf die Tabellen zugegriffen.    
\item Die Vermutung hat sich bestätigt und bei dem Use Case 3 gibt es eine deutliche Performancesteigerung mit dem zusätzlichen B-Tree-Index auf das Datum(K5). Es bleibt nun aber die Frage zu klären, wieso sich der Use Case 2 bei der Konfiguration 5 als einziger verschlechtert hat obwohl die Zugriffstypen im Vergleich zur Konfiguration 3 die selben sind und die B-Tree-Indizierung für BETWEEN-Operatoren eigentlich gut geeignet ist. Wenn man sich den Ausführungsplan anschaut, dann erkennt man, dass bei der Konfiguration 3 der Optimierer bei der Verknüpfung der Tabellen zuerst einen Full-Table-Scan mit der Tabelle Kunde durchführt, die 25-Mal kleiner ist als die Warenkorb\_Has\_Product Tabelle. Und bei der Konfiguration 5 fängt er zuerst mit der großen Tabelle Warenkorb\_Has\_Product an, was trotz der Indizierung etwas länger dauert als wenn er einen vollständigen Tabellenscan mit der Tabelle Kunde gleich zu Beginn der Verknüpfung durchführt.
\item Der Use Case 3 ist mit der Konfiguration 6 tatsächlich noch schneller ausgeführt worden, was hauptsächlich an dem List-Partitioning liegt und nur eine Partition gescannt wird. Die Zeit für den Use Case 2 hat sich jedoch noch weiter verschlechtet. Das liegt wahrscheinlich daran, dass er wieder mit der großen Tabelle Warenkorb\_Has\_Produkt beginnt und aufgrund dieses BETWEEN alle Partitionen gescannt werden.
\item Der Wert für Use Case 2 ist bei der Konfiguration 7 extrem schlecht, der Grund dafür ist wahrscheinlich das Hash-Partitioning mit der BETWEEN-Anweisung überhaupt nicht klar kommt und somit alle 12 Partitionen gescannt werden, was uns auch der Ausführungplan beweist. Der Use Case 4 schneidet bei dieser Konfiguration ebenfalls am schlechtesten ab. Bei der Hash-Partitionierung werden die Daten gleichmäßig verteilt, aber man kann nicht wissen welche Daten in welchen "`Partitions-Topf"' kommen und er scannt für die drei verschiedenen Monate die drei Partitionen( xxxxxxxxxxx muss Ingo fragen, nochmals testen xxxxxxxxxxx).
\item Das Range-Partitioning geht mit der BETWEEN-Anweisung am besten um und wir erhalten somit für den Use Case 2 mit der Konfiguration 8 das beste Ergebnis. Beim Use Case 1 muss er sowieso die ganze Tabelle Produkt scannen und nimmt keinen Index auf den Schlüssel. Die Frage bleibt zu klären wieso der Use Case 1 beim Hash-Partitioning besser abschneidet.
\item Die Teilpartitionierung mit einem B-Tree-Index auf das Datum liefert bei allen Use Cases ein relativ gutes Ergebnis und erweist sich als die beste Konfiguration bei diesen Anwendungsfällen. Vor allem bei dem Use Case 1 und Use Case 4 sind die Messwerte besonders gut.      
\end{enumerate}

\subsection{Alle Messwerte}
\begin{figure}[htp]
\centering
\includegraphics[width=1\textwidth]{Christof/Bilder/TabTeil1.jpg}
\caption{Messwerte Teil 1}
\label{fig:erg1}
\end{figure}

\begin{figure}[htp]
\centering
\includegraphics[width=1\textwidth]{Christof/Bilder/TabTeil2.jpg}
\caption{Messwerte Teil 2}
\label{fig:erg2}
\end{figure}



